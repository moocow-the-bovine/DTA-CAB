## -*- Mode: CPerl -*-
##
## File: DTA::CAB::Analyzer::RewriteSub.pm
## Author: Bryan Jurish <moocow@ling.uni-potsdam.de>
## Description: sub-analysis (LTS, Morph) of rewrite targets

##==============================================================================
## Package: Analyzer::RewriteSub
##==============================================================================
package DTA::CAB::Analyzer::RewriteSub;
use DTA::CAB::Chain;
use DTA::CAB::Analyzer::Morph;
use DTA::CAB::Analyzer::LTS;
use Carp;
use strict;
our @ISA = qw(DTA::CAB::Chain);

## $obj = CLASS_OR_OBJ->new(chain=>\@analyzers, %args)
##  + basic object structure: (see also DTA::CAB::Chain)
##     chain => [$a1, ..., $aN], ##-- sub-analysis chain (e.g. chain=>[$lts,$morph])
##  + new object structure:
##     rwLabel => $label,        ##-- label of source 'rewrite' object (default='rw')
sub new {
  my $that = shift;
  my $asub = $that->SUPER::new(
			       ##-- defaults
			       #analysisClass => 'DTA::CAB::Analyzer::Rewrite::Analysis',
			       label => 'rwsub',

			       ##-- analysis selection
			       rwLabel => 'rw',

			       ##-- user args
			       @_
			      );
  return $asub;
}

## $doc = $anl->analyzeTypes($doc,\%types,\%opts)
##  + perform type-wise analysis of all (text) types in %types (= %{$doc->{types}})
##  + extracts rewrite targets, builds pseudo-type hash, calls sub-chain analyzeTypes(), & expands
sub analyzeTypes {
  my ($asub,$doc,$types,$opts) = @_;
  return $doc if (!$asub->enabled($opts));

  ##-- load
  $asub->ensureLoaded();

  ##-- get rewrite target types
  $types = $doc->types if (!$types);
  my $rwkey   = $asub->{rwLabel};
  my $rwtypes = {
		 map { ($_->{hi}=>bless({text=>$_->{hi}},'DTA::CAB::Token')) }
		 map { $_->{$rwkey} ? @{$_->{$rwkey}} : qw() }
		 values(%$types)
		};

  ##-- analyze rewrite target types
  my ($sublabel);
  foreach (@{$asub->{chain}}) {
    $sublabel = $asub->{label}.'_'.$_->{label};
    next if (defined($opts->{$sublabel}) && !$opts->{$sublabel});
    $_->analyzeTypes($doc,$rwtypes,$opts);
  }

  ##-- delete rewrite target type 'text'
  delete($_->{text}) foreach (values %$rwtypes);

  ##-- expand rewrite target types
  my ($rwtyp);
  foreach (map {$_->{$rwkey} ? @{$_->{$rwkey}} : qw()} values(%$types)) {
    $rwtyp = $rwtypes->{$_->{hi}};
    @$_{keys %$rwtyp} = values %$rwtyp;
  }

  ##-- return
  return $doc;
}

## @keys = $anl->typeKeys()
##  + returns list of type-wise keys to be expanded for this analyzer by expandTypes()
##  + override returns $anl->{rwLabel}
sub typeKeys {
  return $_[0]{rwLabel};
}


##------------------------------------------------------------------------
## Methods: I/O: Input: all

## \@analyzers = $ach->chain()
## \@analyzers = $ach->chain(\%opts)
##  + get selected analyzer chain
###  + NEW: just return $ach->{chain}, since analyzers may still be disabled here (argh)
sub chain {
  my $ach = shift;
  return $ach->{chain};
  #return [grep {$_ && $_->enabled} @{$ach->{chain}}];
}

## $bool = $ach->ensureLoaded()
##  + returns true if any chain member loads successfully (or if the chain is empty)
sub ensureLoaded {
  my $ach = shift;
  my $rc  = 1;
  @{$ach->{chain}} = grep {$_} @{$ach->{chain}}; ##-- hack: chuck undef chain-links here
  foreach (grep {$_} @{$ach->{chain}}) {
    $rc ||= $_->ensureLoaded();
  }
  return $rc;
}

##------------------------------------------------------------------------
## Methods: Analysis: Generic

## $bool = $ach->canAnalyze()
## $bool = $ach->canAnalyze(\%opts)
##  + returns true if analyzer can perform its function (e.g. data is loaded & non-empty)
##  + returns true if ANY analyzers in the chain do to
sub canAnalyze {
  my $ach = shift;
  @{$ach->{chain}} = grep {$_ && $_->canAnalyze} @{$ach->chain(@_)};
  foreach (@{$ach->chain(@_)}) {
    return 1 if ($_->canAnalyze);
  }
  return 1;
}



1; ##-- be happy

__END__
##========================================================================
## POD DOCUMENTATION, auto-generated by podextract.perl, edited

##========================================================================
## NAME
pod

=head1 NAME

DTA::CAB::Analyzer::Rewrite - rewrite analysis via Gfsm::XL cascade

=cut

##========================================================================
## SYNOPSIS
=pod

=head1 SYNOPSIS

 use DTA::CAB::Analyzer::Rewrite;
 
 $rw = DTA::CAB::Analyzer::Rewrite->new(%args);
 
 $rw->analyzeToken($tok);

=cut

##========================================================================
## DESCRIPTION
=pod

=head1 DESCRIPTION

DTA::CAB::Analyzer::Rewrite
is a just a simplified wrapper for
L<DTA::CAB::Analyzer::Automaton::Gfsm::XL|DTA::CAB::Analyzer::Automaton::Gfsm::XL>
which sets the following default options:

 ##-- analysis selection
 analyzeDst     => 'rw',  ##-- output token property
 wantAnalysisLo => 0,     ##-- don't output lower lower labels
 tolowerNI      => 1,     ##-- bash non-initial input characters to lower-case

=cut

##========================================================================
## END POD DOCUMENTATION, auto-generated by podextract.perl

##======================================================================
## Footer
##======================================================================

=pod

=head1 AUTHOR

Bryan Jurish E<lt>jurish@bbaw.deE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2009 by Bryan Jurish

This package is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.4 or,
at your option, any later version of Perl 5 you may have available.

=cut
